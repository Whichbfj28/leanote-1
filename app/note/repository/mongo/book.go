// Code generated by ImplGen.
// Source: book.go

package mongo

import (
	context "context"

	"github.com/coocn-cn/leanote/app/db"
	"github.com/coocn-cn/leanote/app/info"
	model "github.com/coocn-cn/leanote/app/note/model"
	repository "github.com/coocn-cn/leanote/app/note/repository"
	"github.com/coocn-cn/leanote/pkg/errcode"
	"github.com/coocn-cn/leanote/pkg/log"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)

type book struct {
	collection *mgo.Collection
}

// NewBook create a new Book object
func NewBook(ctx context.Context) *book {
	obj := &book{
		collection: db.Notebooks,
	}

	return obj
}

// New is 初始化一个新的领域对象
func (m *book) New(ctx context.Context, data model.BookData) *model.Book {
	dbData := newbookData(data, nil, nil)
	return model.NewBook(dbData)
}

// Count is 获取符合 Predicater 条件的领域对象的个数
func (m *book) Count(ctx context.Context, predicate repository.Predicater) (int, error) {
	return db.Count(m.collection, m.predicates(ctx, predicate)), nil
}

// Find is 加载一个符合 Predicater 条件的领域对象
func (m *book) Find(ctx context.Context, predicate repository.Predicater) (*model.Book, error) {
	books, err := m.FindAll(ctx, predicate)
	if err != nil {
		return nil, err
	}

	if len(books) == 0 {
		return nil, nil
	}

	return books[0], nil
}

// FindAll is 加载所有符合 Predicater 条件的领域对象
func (m *book) FindAll(ctx context.Context, predicate repository.Predicater) ([]*model.Book, error) {
	// 先查是否存在历史记录, 没有则添加之
	books := []info.Notebook{}

	switch predicate.Predicate() {
	case "BookUSNNextBooks":
		params := predicate.Data().(map[string]interface{})

		q := m.collection.Find(m.predicates(ctx, predicate))
		q.Sort("Usn").Limit(params["limit"].(int)).All(&books)
	default:
		m.collection.Find(m.predicates(ctx, predicate)).All(&books)
	}

	resp := make([]*model.Book, 0, len(books))
	for i := range books {
		dbData := newbookData(model.BookData(books[i]), &books[i], m)
		resp = append(resp, model.NewBook(dbData))
	}

	return resp, nil
}

// Save is 保存领域对象到仓储
func (m *book) Save(ctx context.Context, models ...*model.Book) (err error) {
	for _, model := range models {
		mut := model.BookMutation.(*bookData)
		saveData, err := mut.Data(ctx)
		if err != nil {
			return err
		}

		if mut.db() != nil {
			// 更新之
			if ok := db.UpdateByIdAndUserIdMap(m.collection, mut.db().NotebookId.Hex(), mut.db().UserId.Hex(), mut.updates); !ok {
				return errcode.NotFound(ctx, "更新对象失败", mut.db, saveData)
			}
		} else {
			// 保存之
			if err := m.collection.Insert(saveData); err != nil {
				return err
			}
		}

		// 更新 model.mutation 对象状态
		*mut = *newbookData(saveData, (*info.Notebook)(&saveData), m)

		log.G(ctx).WithField("old", mut.old).WithField("new", saveData).Info("Book Save")
	}

	return nil
}

// Delete is 删除仓储中的领域对象
func (m *book) Delete(ctx context.Context, models ...*model.Book) error {
	for _, model := range models {
		data, err := model.Data(ctx)
		if err != nil {
			return err
		}

		if ok := db.DeleteByIdAndUserId(m.collection, data.NotebookId.Hex(), data.UserId.Hex()); !ok {
			return errcode.NotFound(ctx, "删除对象失败", data)
		}
	}

	return nil
}

// DeleteID is 通过ID删除仓储中的领域对象
func (m *book) DeleteID(ctx context.Context, ids ...string) error {
	// TODO: Book.DeleteID(ctx context.Context, id uint64) error Not implemented

	panic("Book.DeleteID(ctx context.Context, id uint64) error Not implemented")
}

func (m *book) predicates(ctx context.Context, predicate repository.Predicater) bson.M {
	switch predicate.Predicate() {
	case "BookID":
		params := predicate.Data().(map[string]string)
		return bson.M{"_id": bson.ObjectIdHex(params["id"])}
	case "BookIDs":
		params := predicate.Data().(map[string][]string)

		ids := params["ids"]
		hexIDs := make([]bson.ObjectId, 0, len(ids))
		for _, v := range ids {
			hexIDs = append(hexIDs, bson.ObjectIdHex(v))
		}

		return bson.M{"_id": bson.M{"$in": hexIDs}}
	case "BookUserAndIDs":
		params := predicate.Data().(map[string][]string)

		ids := params["ids"]
		hexIDs := make([]bson.ObjectId, 0, len(ids))
		for _, v := range ids {
			hexIDs = append(hexIDs, bson.ObjectIdHex(v))
		}

		return bson.M{"UserId": bson.ObjectIdHex(params["userID"][0]), "_id": bson.M{"$in": hexIDs}}
	case "BookUserAndID":
		params := predicate.Data().(map[string]string)
		return bson.M{"UserId": bson.ObjectIdHex(params["userID"]), "_id": bson.ObjectIdHex(params["id"])}
	case "BookUserAndParentIDAndDelete":
		params := predicate.Data().(map[string]interface{})
		return bson.M{
			"ParentNotebookId": bson.ObjectIdHex(params["parentID"].(string)),
			"UserId":           bson.ObjectIdHex(params["userID"].(string)),
			"IsDeleted":        params["delete"].(bool),
		}
	case "BookUserAndBookIDAndTrashAndDelete":
		params := predicate.Data().(map[string]interface{})
		return bson.M{
			"UserId":     bson.ObjectIdHex(params["userID"].(string)),
			"NotebookId": bson.ObjectIdHex(params["bookID"].(string)),
			"IsTrash":    params["trash"].(bool),
			"IsDeleted":  params["delete"].(bool),
		}
	case "BookUserAndNotDelete":
		params := predicate.Data().(map[string]string)
		return bson.M{
			"UserId": bson.ObjectIdHex(params["userID"]),
			"$or": []bson.M{
				{"IsDeleted": false},
				{"IsDeleted": bson.M{"$exists": false}},
			}}
	case "BookUserAndURLTitle":
		params := predicate.Data().(map[string]string)
		return bson.M{"UserId": bson.ObjectIdHex(params["userID"]), "UrlTitle": encodeValue(params["urlTitle"])}
	case "BookUSNNextBooks":
		params := predicate.Data().(map[string]interface{})
		return bson.M{"UserId": bson.ObjectIdHex(params["userID"].(string)), "Usn": bson.M{"$gt": params["usn"].(int)}}
	}

	panic(errcode.Unimplemented(ctx, "加载条件未实现", predicate.Predicate()).Error())
}
