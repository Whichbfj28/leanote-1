// Code generated by ImplGen.
// Source: note_repository.go

package mongo

import (
	context "context"

	"github.com/coocn-cn/leanote/app/db"
	"github.com/coocn-cn/leanote/app/info"
	model "github.com/coocn-cn/leanote/app/note/model"
	repository "github.com/coocn-cn/leanote/app/note/repository"
	"github.com/coocn-cn/leanote/pkg/errcode"
	"github.com/coocn-cn/leanote/pkg/log"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)

type note struct {
	baseRepository
	collection *mgo.Collection
}

// NewNote create a new note object
func NewNote(ctx context.Context) *note {
	obj := &note{
		collection: db.Notes,
	}

	return obj
}

// New is 初始化一个新的领域对象
func (m *note) New(ctx context.Context, data model.NoteData) *model.Note {
	dbData := newnoteData(data, nil, m)
	return model.NewNote(dbData)
}

// Count is 获取符合 Predicater 条件的领域对象的个数
func (m *note) Count(ctx context.Context, predicate repository.Predicater) (int, error) {
	return db.Count(db.Notebooks, m.predicates(ctx, predicate)), nil
}

// Find is 加载一个符合 Predicater 条件的领域对象
func (m *note) Find(ctx context.Context, predicate repository.Predicater) (*model.Note, error) {
	notes, err := m.FindAll(ctx, repository.NewBuilder(predicate).WithLimit(1))
	if err != nil {
		return nil, err
	}

	if len(notes) == 0 {
		return nil, nil
	}

	return notes[0], nil
}

// FindAll is 加载所有符合 Predicater 条件的领域对象
func (m *note) FindAll(ctx context.Context, predicate repository.Predicater) ([]*model.Note, error) {
	notes := []info.Note{}
	q := m.collection.Find(m.predicates(ctx, predicate))

	if builder, ok := predicate.(repository.PredicateBuilder); ok {
		params := builder.BuildParams()

		if sort, ok := params["_common_sort"].(string); ok {
			q = q.Sort(sort)
		}
		if skip, ok := params["_common_skip"].(int); ok {
			q = q.Skip(skip)
		}
		if limit, ok := params["_common_limit"].(int); ok {
			q = q.Limit(limit)
		}
		if fields, ok := params["_common_select"].([]string); ok {
			selector := make(map[string]bool, len(fields))
			for _, field := range fields {
				selector[field] = true
			}
			q = q.Select(selector)
		}

	}

	q.All(&notes)

	resp := make([]*model.Note, 0, len(notes))
	for i := range notes {
		dbData := newnoteData(model.NoteData(notes[i]), &notes[i], m)
		resp = append(resp, model.NewNote(dbData))
	}

	return resp, nil
}

// Save is 保存领域对象到仓储
func (m *note) Save(ctx context.Context, models ...*model.Note) error {
	for _, model := range models {
		mut := model.NoteMutation.(*noteData)
		saveData, err := mut.Data(ctx)
		if err != nil {
			return err
		}

		if mut.db() != nil {
			// 更新之
			if ok := db.UpdateByIdAndUserIdMap(m.collection, mut.db().NoteId.Hex(), mut.db().UserId.Hex(), mut.updates); !ok {
				return errcode.NotFound(ctx, "更新对象失败", mut.db, saveData)
			}
		} else {
			// 保存之
			db.Insert(m.collection, info.Note(saveData))
		}

		// 更新 model.mutation 对象状态
		*mut = *newnoteData(saveData, (*info.Note)(&saveData), m)

		log.G(ctx).WithField("old", mut.old).WithField("new", saveData).Info("Note Save")
	}

	return nil
}

// Delete is 删除仓储中的领域对象
func (m *note) Delete(ctx context.Context, models ...*model.Note) error {
	for _, model := range models {
		data, err := model.Data(ctx)
		if err != nil {
			return err
		}

		if ok := db.DeleteByIdAndUserId(m.collection, data.NoteId.Hex(), data.UserId.Hex()); !ok {
			return errcode.NotFound(ctx, "删除对象失败", data)
		}
	}

	return nil
}

// DeleteID is 通过ID删除仓储中的领域对象
func (m *note) DeleteID(ctx context.Context, ids ...uint64) error {
	// TODO: note.DeleteID(ctx context.Context, ids ...uint64) error Not implemented

	panic("note.DeleteID(ctx context.Context, ids ...uint64) error Not implemented")
}

func (m *note) predicates(ctx context.Context, predicate repository.Predicater) bson.M {
	var query bson.M

	switch predicate.Predicate() {
	case "NoteBookID":
		params := predicate.Data().(map[string]string)
		query = bson.M{"NotebookId": bson.ObjectIdHex(params["bookID"])}
	case "NoteIDAndBlog":
		params := predicate.Data().(map[string]interface{})
		query = bson.M{
			"_id": bson.ObjectIdHex(params["id"].(string)),
		}

		if params["blog"].(bool) {
			query["IsBlog"] = true
		}
	case "NoteSrc":
		params := predicate.Data().(map[string]interface{})
		query = bson.M{
			"Src": params["src"].(string),
		}
	case "NoteBlog":
		query = bson.M{
			"IsBlog": true,
		}
	case "NoteTags":
		params := predicate.Data().(map[string]interface{})

		ids := params["tags"].([]string)
		hexTags := make([]bson.ObjectId, 0, len(ids))
		for _, v := range ids {
			hexTags = append(hexTags, bson.ObjectIdHex(v))
		}

		query = bson.M{
			"Tags": bson.M{"$in": hexTags},
		}
	case "NoteNexts":
		params := predicate.Data().(map[string]interface{})
		query = bson.M{
			"Usn": bson.M{"$gt": params["usn"].(int)},
		}
	case "NoteBookIDAndBlog":
		params := predicate.Data().(map[string]interface{})
		query = bson.M{
			"NotebookId": bson.ObjectIdHex(params["bookID"].(string)),
		}

		if params["blog"].(bool) {
			query["IsBlog"] = true
		}
	case "NoteSearchTags":
		params := predicate.Data().(map[string]interface{})
		query = bson.M{
			"Tags": bson.M{"$all": params["tags"].([]string)},
		}
	case "NoteSearchTitleAndDesc":
		params := predicate.Data().(map[string]interface{})

		// 利用标题和desc, 不用content,不是trash的
		key := params["query"].(string)
		query = bson.M{
			"_id": bson.M{"$nin": params["excludeIDs"].([]string)},
			"$or": []bson.M{
				{"Title": bson.M{"$regex": bson.RegEx{".*?" + key + ".*", "i"}}},
				{"Desc": bson.M{"$regex": bson.RegEx{".*?" + key + ".*", "i"}}},
			},
		}
	case "NoteSearchContent":
		params := predicate.Data().(map[string]interface{})

		// 利用标题和desc, 不用content,不是trash的
		key := params["query"].(string)
		query = bson.M{
			"_id":     bson.M{"$nin": params["excludeIDs"].([]string)},
			"Content": bson.M{"$regex": bson.RegEx{".*?" + key + ".*", "i"}},
		}

		if params["blog"].(bool) {
			query["IsBlog"] = true
		}
	default:
		return m.predicateToMongo(ctx, predicate)
	}

	return m.commonFields(predicate, query)
}
